{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<::objc::macros::msg_send macros>","byte_start":641,"byte_end":647,"line_start":15,"line_end":15,"column_start":37,"column_end":43,"is_primary":true,"text":[{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate :: __send_message","highlight_start":37,"highlight_end":43}],"label":"consider giving `result` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs","byte_start":17901,"byte_end":17934,"line_start":479,"line_end":479,"column_start":9,"column_end":42,"is_primary":false,"text":[{"text":"        msg_send![self, releaseGlobally];","highlight_start":9,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"msg_send!","def_site_span":{"file_name":"<::objc::macros::msg_send macros>","byte_start":0,"byte_end":1036,"line_start":1,"line_end":23,"column_start":1,"column_end":6,"is_primary":false,"text":[{"text":"(super ($ obj : expr, $ superclass : expr), $ name : ident) =>","highlight_start":1,"highlight_end":63},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":62},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ())","highlight_start":1,"highlight_end":61},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6},{"text":"(super ($ obj : expr, $ superclass : expr), $ ($ name : ident : $ arg : expr)","highlight_start":1,"highlight_end":78},{"text":" +) =>","highlight_start":1,"highlight_end":7},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":73},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ name : ident) =>","highlight_start":1,"highlight_end":40},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate :: __send_message","highlight_start":1,"highlight_end":77},{"text":"     (& * $ obj, sel, ())","highlight_start":1,"highlight_end":26},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ ($ name : ident : $ arg : expr) +) =>","highlight_start":1,"highlight_end":61},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_message (& * $ obj, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":53},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs:479:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m479\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        msg_send![self, releaseGlobally];\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider giving `result` a type\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<::objc::macros::msg_send macros>","byte_start":884,"byte_end":890,"line_start":20,"line_end":20,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":45,"highlight_end":51}],"label":"consider giving `result` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs","byte_start":99481,"byte_end":99518,"line_start":2798,"line_end":2798,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        msg_send![self, setBezelStyle:style];","highlight_start":9,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"msg_send!","def_site_span":{"file_name":"<::objc::macros::msg_send macros>","byte_start":0,"byte_end":1036,"line_start":1,"line_end":23,"column_start":1,"column_end":6,"is_primary":false,"text":[{"text":"(super ($ obj : expr, $ superclass : expr), $ name : ident) =>","highlight_start":1,"highlight_end":63},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":62},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ())","highlight_start":1,"highlight_end":61},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6},{"text":"(super ($ obj : expr, $ superclass : expr), $ ($ name : ident : $ arg : expr)","highlight_start":1,"highlight_end":78},{"text":" +) =>","highlight_start":1,"highlight_end":7},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":73},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ name : ident) =>","highlight_start":1,"highlight_end":40},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate :: __send_message","highlight_start":1,"highlight_end":77},{"text":"     (& * $ obj, sel, ())","highlight_start":1,"highlight_end":26},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ ($ name : ident : $ arg : expr) +) =>","highlight_start":1,"highlight_end":61},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_message (& * $ obj, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":53},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs:2798:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2798\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        msg_send![self, setBezelStyle:style];\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider giving `result` a type\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<::objc::macros::msg_send macros>","byte_start":884,"byte_end":890,"line_start":20,"line_end":20,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":45,"highlight_end":51}],"label":"consider giving `result` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs","byte_start":121025,"byte_end":121063,"line_start":3403,"line_end":3403,"column_start":9,"column_end":47,"is_primary":false,"text":[{"text":"        msg_send![self, setEditable:editable];","highlight_start":9,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"msg_send!","def_site_span":{"file_name":"<::objc::macros::msg_send macros>","byte_start":0,"byte_end":1036,"line_start":1,"line_end":23,"column_start":1,"column_end":6,"is_primary":false,"text":[{"text":"(super ($ obj : expr, $ superclass : expr), $ name : ident) =>","highlight_start":1,"highlight_end":63},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":62},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ())","highlight_start":1,"highlight_end":61},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6},{"text":"(super ($ obj : expr, $ superclass : expr), $ ($ name : ident : $ arg : expr)","highlight_start":1,"highlight_end":78},{"text":" +) =>","highlight_start":1,"highlight_end":7},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":73},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ name : ident) =>","highlight_start":1,"highlight_end":40},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate :: __send_message","highlight_start":1,"highlight_end":77},{"text":"     (& * $ obj, sel, ())","highlight_start":1,"highlight_end":26},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ ($ name : ident : $ arg : expr) +) =>","highlight_start":1,"highlight_end":61},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_message (& * $ obj, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":53},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs:3403:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        msg_send![self, setEditable:editable];\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider giving `result` a type\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = \"hello\".chars().rev().collect();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nA common example is the `collect` method on `Iterator`. It has a generic type\nparameter with a `FromIterator` bound, which for a `char` iterator is\nimplemented by `Vec` and `String` among others. Consider the following snippet\nthat reverses the characters of a string:\n\nIn the first code example, the compiler cannot infer what the type of `x` should\nbe: `Vec<char>` and `String` are both suitable candidates. To specify which type\nto use, you can use a type annotation on `x`:\n\n```\nlet x: Vec<char> = \"hello\".chars().rev().collect();\n```\n\nIt is not necessary to annotate the full type. Once the ambiguity is resolved,\nthe compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"<::objc::macros::msg_send macros>","byte_start":884,"byte_end":890,"line_start":20,"line_end":20,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":45,"highlight_end":51}],"label":"consider giving `result` a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs","byte_start":121127,"byte_end":121165,"line_start":3406,"line_end":3406,"column_start":9,"column_end":47,"is_primary":false,"text":[{"text":"        msg_send![self, setStringValue:label];","highlight_start":9,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"msg_send!","def_site_span":{"file_name":"<::objc::macros::msg_send macros>","byte_start":0,"byte_end":1036,"line_start":1,"line_end":23,"column_start":1,"column_end":6,"is_primary":false,"text":[{"text":"(super ($ obj : expr, $ superclass : expr), $ name : ident) =>","highlight_start":1,"highlight_end":63},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":62},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ())","highlight_start":1,"highlight_end":61},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6},{"text":"(super ($ obj : expr, $ superclass : expr), $ ($ name : ident : $ arg : expr)","highlight_start":1,"highlight_end":78},{"text":" +) =>","highlight_start":1,"highlight_end":7},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_super_message (& * $ obj, $ superclass, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":73},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ name : ident) =>","highlight_start":1,"highlight_end":40},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ name) ; let result ; match $ crate :: __send_message","highlight_start":1,"highlight_end":77},{"text":"     (& * $ obj, sel, ())","highlight_start":1,"highlight_end":26},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ; ($ obj : expr, $ ($ name : ident : $ arg : expr) +) =>","highlight_start":1,"highlight_end":61},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     let sel = sel ! ($ ($ name :) +) ; let result ; match $ crate ::","highlight_start":1,"highlight_end":70},{"text":"     __send_message (& * $ obj, sel, ($ ($ arg,) *))","highlight_start":1,"highlight_end":53},{"text":"     { Err (s) => panic ! (\"{}\", s), Ok (r) => result = r, } result","highlight_start":1,"highlight_end":68},{"text":" }) ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0282]\u001b[0m\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/bobren/.cargo/registry/src/github.com-1ecc6299db9ec823/cocoa-0.9.2/src/appkit.rs:3406:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        msg_send![self, setStringValue:label];\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider giving `result` a type\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 4 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 4 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0282`.\u001b[0m\n"}
